---

title: "[백준] 1780번 - 종이의 개수"
date: 2020-05-22 16:30:00 +0800
categories: [1.Studying, 백준&프로그래머스]
tags: [algorithm, 백준, baekjoon, 분할정복, divide&conquer]
---



------

**백준 온라인 저지의 1780번 종이의 개수 문제입니다.**

[링크] [https://www.acmicpc.net/problem/1780](https://www.acmicpc.net/problem/1780)

---

## **문제 조건과 설명**

N×N크기의 행렬로 표현되는 종이가 있다. 종이의 각 칸에는 -1, 0, 1의 세 값 중 하나가 저장되어 있다. 우리는 이 행렬을 적절한 크기로 자르려고 하는데, 이때 다음의 규칙에 따라 자르려고 한다.

1. 만약 종이가 모두 같은 수로 되어 있다면 이 종이를 그대로 사용한다.
2. (1)이 아닌 경우에는 종이를 같은 크기의 9개의 종이로 자르고, 각각의 잘린 종이에 대해서 (1)의 과정을 반복한다.

이와 같이 종이를 잘랐을 때, -1로만 채워진 종이의 개수, 0으로만 채워진 종이의 개수, 1로만 채워진 종이의 개수를 구해내는 프로그램을 작성하시오.

------




## **Input**

첫째 줄에 N(1≤N≤3^7, N은 3^k 꼴)이 주어진다. 다음 N개의 줄에는 N개의 정수로 행렬이 주어진다.

------



## **Output**

첫째 줄에 -1로만 채워진 종이의 개수를, 둘째 줄에 0으로만 채워진 종이의 개수를, 셋째 줄에 1로만 채워진 종이의 개수를 출력한다.

---



## **생각한 아이디어**

이 문제가 전형적인 **분할정복 아이디어로 푸는 문제**라고 합니다.

그래서 이러한 유형의 문제를 익혀두면 많은 도움이 된다고 많은 분들이 이야기 하기도 합니다.

먼저, **종이 내의 모든 숫자들이 같은 수라면, 그 종이는 분할하지 않고 넘어갑니다.**

하지만, **종이 내에 다른 숫자가 하나라도 포함된다면, 그 종이를 9개의 종이로 자르고, 잘린 종이마다 다시 숫자가 모두 같은지 아닌지를 판단**합니다.

즉, 전체를 여러 개로 분할하여(->여러 개의 작은 부분으로 나누고), 같은 알고리즘을 적용시켜 나가는 것(->나눈 작은 문제를 해결)입니다.

------

예를 들어, 9*9 종이로 시작한다고 가정해 보겠습니다.

![](https://i.imgur.com/jnpTftA.png)

> 9 x 9 로 된 큰 정사각형 종이

총 81칸에 대해서, **숫자가 같은지 다른지 검사합니다.** 모두 같으면, 분할하지 않고 넘어갑니다.

만약, 위 종이의 모든 칸이 1이었다면, 1로만 채워진 종이 1개가 정답이었을 것입니다.

만약 단 하나라도 다른 숫자가 있다면 아래와 같이 큰 종이를 **9개로 분할**합니다.

![](https://i.imgur.com/a0MyX2Y.png)

> 정사각형 종이를 9분할하게 되면, 그 작은 단위의 한 변의 길이는 1/3이 됩니다.

즉, 처음에 9 * 9 종이었다면, 9분할 시 3 * 3 종이 9개로 분할되는 것입니다.

그리고 이렇게 나눈 **작은 단위 정사각형들에 대해서** 다시 **숫자가 같은지 다른지 검사합니다.**

숫자가 다르다면, 그 종이를 또 9분할해야 합니다.

위의 경우에는 **3 * 3 종이를 9분할하면 1 * 1 짜리 종이 9개**가 만들어질 것입니다.

그리고 이것이 분할할 수 있는 최소의 종이 크기가 됩니다.

------



## **소스코드**

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <cmath>

using namespace std;

int result[3];
int map[2200][2200];

// 단위 종이 내 모든 칸들이 모두 같은지 아닌지 판단하는 함수
bool check(int row, int col, int num) {
	// 시작점
	int start = map[row][col];
	for (int i = row; i < row + num; i++) {
		for (int j = col; j < col + num; j++) {
			if (start != map[i][j])
				return false;
		}
	}
	return true;
}

// 9분할로 나눠보는 함수
void divide(int row, int col, int num) {

	// 지금 단위 종이 내 모든 칸들의 값이 같을 경우
	if (check(row, col, num)) {
		result[map[row][col]]++;
	}
	else {
		// 새로운 단위사이즈를 만든다.
		int size = num / 3; // 처음에 num 27이었다면 다음 단위 정사각형은 한 변의 길이가 9
		
		for (int i = 0; i < 3; i++) {
			for (int j = 0; j < 3; j++) {
				divide(row + size * i, col + size * j, size);
			}
		}
	}
}


int main() {

	int N;
	scanf("%d", &N);

	for (int i = 0; i < N; i++) {
		for (int j = 0; j < N; j++) {

			int input;
			scanf("%d", &input);
			input++; // -1,0,1 을 각각 0,1,2로 표현		
			map[i][j] = input;
		}
	}
	divide(0, 0, N);
	printf("%d\n%d\n%d", result[0], result[1], result[2]);

}
```

------

**유사한 문제** : [백준] 1992번 - 쿼드트리 ([https://www.acmicpc.net/problem/1992](https://www.acmicpc.net/problem/1992))